package filter

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/pehks1980/gb_go_best/kurs/app1/filter.Parse -o ./parse_mock_test.go

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ParseMock implements Parse
type ParseMock struct {
	t minimock.Tester

	funcParseCondition          func(cmd []string, colsMask map[string]int) (cp1 *Condition, err error)
	inspectFuncParseCondition   func(cmd []string, colsMask map[string]int)
	afterParseConditionCounter  uint64
	beforeParseConditionCounter uint64
	ParseConditionMock          mParseMockParseCondition

	funcParseHeading          func(fileCols []string, flgCols []string) (m1 map[string]int, m2 map[string]int)
	inspectFuncParseHeading   func(fileCols []string, flgCols []string)
	afterParseHeadingCounter  uint64
	beforeParseHeadingCounter uint64
	ParseHeadingMock          mParseMockParseHeading
}

// NewParseMock returns a mock for Parse
func NewParseMock(t minimock.Tester) *ParseMock {
	m := &ParseMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ParseConditionMock = mParseMockParseCondition{mock: m}
	m.ParseConditionMock.callArgs = []*ParseMockParseConditionParams{}

	m.ParseHeadingMock = mParseMockParseHeading{mock: m}
	m.ParseHeadingMock.callArgs = []*ParseMockParseHeadingParams{}

	return m
}

type mParseMockParseCondition struct {
	mock               *ParseMock
	defaultExpectation *ParseMockParseConditionExpectation
	expectations       []*ParseMockParseConditionExpectation

	callArgs []*ParseMockParseConditionParams
	mutex    sync.RWMutex
}

// ParseMockParseConditionExpectation specifies expectation struct of the Parse.ParseCondition
type ParseMockParseConditionExpectation struct {
	mock    *ParseMock
	params  *ParseMockParseConditionParams
	results *ParseMockParseConditionResults
	Counter uint64
}

// ParseMockParseConditionParams contains parameters of the Parse.ParseCondition
type ParseMockParseConditionParams struct {
	cmd      []string
	colsMask map[string]int
}

// ParseMockParseConditionResults contains results of the Parse.ParseCondition
type ParseMockParseConditionResults struct {
	cp1 *Condition
	err error
}

// Expect sets up expected params for Parse.ParseCondition
func (mmParseCondition *mParseMockParseCondition) Expect(cmd []string, colsMask map[string]int) *mParseMockParseCondition {
	if mmParseCondition.mock.funcParseCondition != nil {
		mmParseCondition.mock.t.Fatalf("ParseMock.ParseCondition mock is already set by Set")
	}

	if mmParseCondition.defaultExpectation == nil {
		mmParseCondition.defaultExpectation = &ParseMockParseConditionExpectation{}
	}

	mmParseCondition.defaultExpectation.params = &ParseMockParseConditionParams{cmd, colsMask}
	for _, e := range mmParseCondition.expectations {
		if minimock.Equal(e.params, mmParseCondition.defaultExpectation.params) {
			mmParseCondition.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseCondition.defaultExpectation.params)
		}
	}

	return mmParseCondition
}

// Inspect accepts an inspector function that has same arguments as the Parse.ParseCondition
func (mmParseCondition *mParseMockParseCondition) Inspect(f func(cmd []string, colsMask map[string]int)) *mParseMockParseCondition {
	if mmParseCondition.mock.inspectFuncParseCondition != nil {
		mmParseCondition.mock.t.Fatalf("Inspect function is already set for ParseMock.ParseCondition")
	}

	mmParseCondition.mock.inspectFuncParseCondition = f

	return mmParseCondition
}

// Return sets up results that will be returned by Parse.ParseCondition
func (mmParseCondition *mParseMockParseCondition) Return(cp1 *Condition, err error) *ParseMock {
	if mmParseCondition.mock.funcParseCondition != nil {
		mmParseCondition.mock.t.Fatalf("ParseMock.ParseCondition mock is already set by Set")
	}

	if mmParseCondition.defaultExpectation == nil {
		mmParseCondition.defaultExpectation = &ParseMockParseConditionExpectation{mock: mmParseCondition.mock}
	}
	mmParseCondition.defaultExpectation.results = &ParseMockParseConditionResults{cp1, err}
	return mmParseCondition.mock
}

//Set uses given function f to mock the Parse.ParseCondition method
func (mmParseCondition *mParseMockParseCondition) Set(f func(cmd []string, colsMask map[string]int) (cp1 *Condition, err error)) *ParseMock {
	if mmParseCondition.defaultExpectation != nil {
		mmParseCondition.mock.t.Fatalf("Default expectation is already set for the Parse.ParseCondition method")
	}

	if len(mmParseCondition.expectations) > 0 {
		mmParseCondition.mock.t.Fatalf("Some expectations are already set for the Parse.ParseCondition method")
	}

	mmParseCondition.mock.funcParseCondition = f
	return mmParseCondition.mock
}

// When sets expectation for the Parse.ParseCondition which will trigger the result defined by the following
// Then helper
func (mmParseCondition *mParseMockParseCondition) When(cmd []string, colsMask map[string]int) *ParseMockParseConditionExpectation {
	if mmParseCondition.mock.funcParseCondition != nil {
		mmParseCondition.mock.t.Fatalf("ParseMock.ParseCondition mock is already set by Set")
	}

	expectation := &ParseMockParseConditionExpectation{
		mock:   mmParseCondition.mock,
		params: &ParseMockParseConditionParams{cmd, colsMask},
	}
	mmParseCondition.expectations = append(mmParseCondition.expectations, expectation)
	return expectation
}

// Then sets up Parse.ParseCondition return parameters for the expectation previously defined by the When method
func (e *ParseMockParseConditionExpectation) Then(cp1 *Condition, err error) *ParseMock {
	e.results = &ParseMockParseConditionResults{cp1, err}
	return e.mock
}

// ParseCondition implements Parse
func (mmParseCondition *ParseMock) ParseCondition(cmd []string, colsMask map[string]int) (cp1 *Condition, err error) {
	mm_atomic.AddUint64(&mmParseCondition.beforeParseConditionCounter, 1)
	defer mm_atomic.AddUint64(&mmParseCondition.afterParseConditionCounter, 1)

	if mmParseCondition.inspectFuncParseCondition != nil {
		mmParseCondition.inspectFuncParseCondition(cmd, colsMask)
	}

	mm_params := &ParseMockParseConditionParams{cmd, colsMask}

	// Record call args
	mmParseCondition.ParseConditionMock.mutex.Lock()
	mmParseCondition.ParseConditionMock.callArgs = append(mmParseCondition.ParseConditionMock.callArgs, mm_params)
	mmParseCondition.ParseConditionMock.mutex.Unlock()

	for _, e := range mmParseCondition.ParseConditionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmParseCondition.ParseConditionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseCondition.ParseConditionMock.defaultExpectation.Counter, 1)
		mm_want := mmParseCondition.ParseConditionMock.defaultExpectation.params
		mm_got := ParseMockParseConditionParams{cmd, colsMask}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseCondition.t.Errorf("ParseMock.ParseCondition got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseCondition.ParseConditionMock.defaultExpectation.results
		if mm_results == nil {
			mmParseCondition.t.Fatal("No results are set for the ParseMock.ParseCondition")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmParseCondition.funcParseCondition != nil {
		return mmParseCondition.funcParseCondition(cmd, colsMask)
	}
	mmParseCondition.t.Fatalf("Unexpected call to ParseMock.ParseCondition. %v %v", cmd, colsMask)
	return
}

// ParseConditionAfterCounter returns a count of finished ParseMock.ParseCondition invocations
func (mmParseCondition *ParseMock) ParseConditionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseCondition.afterParseConditionCounter)
}

// ParseConditionBeforeCounter returns a count of ParseMock.ParseCondition invocations
func (mmParseCondition *ParseMock) ParseConditionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseCondition.beforeParseConditionCounter)
}

// Calls returns a list of arguments used in each call to ParseMock.ParseCondition.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseCondition *mParseMockParseCondition) Calls() []*ParseMockParseConditionParams {
	mmParseCondition.mutex.RLock()

	argCopy := make([]*ParseMockParseConditionParams, len(mmParseCondition.callArgs))
	copy(argCopy, mmParseCondition.callArgs)

	mmParseCondition.mutex.RUnlock()

	return argCopy
}

// MinimockParseConditionDone returns true if the count of the ParseCondition invocations corresponds
// the number of defined expectations
func (m *ParseMock) MinimockParseConditionDone() bool {
	for _, e := range m.ParseConditionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseConditionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseConditionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseCondition != nil && mm_atomic.LoadUint64(&m.afterParseConditionCounter) < 1 {
		return false
	}
	return true
}

// MinimockParseConditionInspect logs each unmet expectation
func (m *ParseMock) MinimockParseConditionInspect() {
	for _, e := range m.ParseConditionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParseMock.ParseCondition with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseConditionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseConditionCounter) < 1 {
		if m.ParseConditionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParseMock.ParseCondition")
		} else {
			m.t.Errorf("Expected call to ParseMock.ParseCondition with params: %#v", *m.ParseConditionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseCondition != nil && mm_atomic.LoadUint64(&m.afterParseConditionCounter) < 1 {
		m.t.Error("Expected call to ParseMock.ParseCondition")
	}
}

type mParseMockParseHeading struct {
	mock               *ParseMock
	defaultExpectation *ParseMockParseHeadingExpectation
	expectations       []*ParseMockParseHeadingExpectation

	callArgs []*ParseMockParseHeadingParams
	mutex    sync.RWMutex
}

// ParseMockParseHeadingExpectation specifies expectation struct of the Parse.ParseHeading
type ParseMockParseHeadingExpectation struct {
	mock    *ParseMock
	params  *ParseMockParseHeadingParams
	results *ParseMockParseHeadingResults
	Counter uint64
}

// ParseMockParseHeadingParams contains parameters of the Parse.ParseHeading
type ParseMockParseHeadingParams struct {
	fileCols []string
	flgCols  []string
}

// ParseMockParseHeadingResults contains results of the Parse.ParseHeading
type ParseMockParseHeadingResults struct {
	m1 map[string]int
	m2 map[string]int
}

// Expect sets up expected params for Parse.ParseHeading
func (mmParseHeading *mParseMockParseHeading) Expect(fileCols []string, flgCols []string) *mParseMockParseHeading {
	if mmParseHeading.mock.funcParseHeading != nil {
		mmParseHeading.mock.t.Fatalf("ParseMock.ParseHeading mock is already set by Set")
	}

	if mmParseHeading.defaultExpectation == nil {
		mmParseHeading.defaultExpectation = &ParseMockParseHeadingExpectation{}
	}

	mmParseHeading.defaultExpectation.params = &ParseMockParseHeadingParams{fileCols, flgCols}
	for _, e := range mmParseHeading.expectations {
		if minimock.Equal(e.params, mmParseHeading.defaultExpectation.params) {
			mmParseHeading.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmParseHeading.defaultExpectation.params)
		}
	}

	return mmParseHeading
}

// Inspect accepts an inspector function that has same arguments as the Parse.ParseHeading
func (mmParseHeading *mParseMockParseHeading) Inspect(f func(fileCols []string, flgCols []string)) *mParseMockParseHeading {
	if mmParseHeading.mock.inspectFuncParseHeading != nil {
		mmParseHeading.mock.t.Fatalf("Inspect function is already set for ParseMock.ParseHeading")
	}

	mmParseHeading.mock.inspectFuncParseHeading = f

	return mmParseHeading
}

// Return sets up results that will be returned by Parse.ParseHeading
func (mmParseHeading *mParseMockParseHeading) Return(m1 map[string]int, m2 map[string]int) *ParseMock {
	if mmParseHeading.mock.funcParseHeading != nil {
		mmParseHeading.mock.t.Fatalf("ParseMock.ParseHeading mock is already set by Set")
	}

	if mmParseHeading.defaultExpectation == nil {
		mmParseHeading.defaultExpectation = &ParseMockParseHeadingExpectation{mock: mmParseHeading.mock}
	}
	mmParseHeading.defaultExpectation.results = &ParseMockParseHeadingResults{m1, m2}
	return mmParseHeading.mock
}

//Set uses given function f to mock the Parse.ParseHeading method
func (mmParseHeading *mParseMockParseHeading) Set(f func(fileCols []string, flgCols []string) (m1 map[string]int, m2 map[string]int)) *ParseMock {
	if mmParseHeading.defaultExpectation != nil {
		mmParseHeading.mock.t.Fatalf("Default expectation is already set for the Parse.ParseHeading method")
	}

	if len(mmParseHeading.expectations) > 0 {
		mmParseHeading.mock.t.Fatalf("Some expectations are already set for the Parse.ParseHeading method")
	}

	mmParseHeading.mock.funcParseHeading = f
	return mmParseHeading.mock
}

// When sets expectation for the Parse.ParseHeading which will trigger the result defined by the following
// Then helper
func (mmParseHeading *mParseMockParseHeading) When(fileCols []string, flgCols []string) *ParseMockParseHeadingExpectation {
	if mmParseHeading.mock.funcParseHeading != nil {
		mmParseHeading.mock.t.Fatalf("ParseMock.ParseHeading mock is already set by Set")
	}

	expectation := &ParseMockParseHeadingExpectation{
		mock:   mmParseHeading.mock,
		params: &ParseMockParseHeadingParams{fileCols, flgCols},
	}
	mmParseHeading.expectations = append(mmParseHeading.expectations, expectation)
	return expectation
}

// Then sets up Parse.ParseHeading return parameters for the expectation previously defined by the When method
func (e *ParseMockParseHeadingExpectation) Then(m1 map[string]int, m2 map[string]int) *ParseMock {
	e.results = &ParseMockParseHeadingResults{m1, m2}
	return e.mock
}

// ParseHeading implements Parse
func (mmParseHeading *ParseMock) ParseHeading(fileCols []string, flgCols []string) (m1 map[string]int, m2 map[string]int) {
	mm_atomic.AddUint64(&mmParseHeading.beforeParseHeadingCounter, 1)
	defer mm_atomic.AddUint64(&mmParseHeading.afterParseHeadingCounter, 1)

	if mmParseHeading.inspectFuncParseHeading != nil {
		mmParseHeading.inspectFuncParseHeading(fileCols, flgCols)
	}

	mm_params := &ParseMockParseHeadingParams{fileCols, flgCols}

	// Record call args
	mmParseHeading.ParseHeadingMock.mutex.Lock()
	mmParseHeading.ParseHeadingMock.callArgs = append(mmParseHeading.ParseHeadingMock.callArgs, mm_params)
	mmParseHeading.ParseHeadingMock.mutex.Unlock()

	for _, e := range mmParseHeading.ParseHeadingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.m2
		}
	}

	if mmParseHeading.ParseHeadingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmParseHeading.ParseHeadingMock.defaultExpectation.Counter, 1)
		mm_want := mmParseHeading.ParseHeadingMock.defaultExpectation.params
		mm_got := ParseMockParseHeadingParams{fileCols, flgCols}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmParseHeading.t.Errorf("ParseMock.ParseHeading got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmParseHeading.ParseHeadingMock.defaultExpectation.results
		if mm_results == nil {
			mmParseHeading.t.Fatal("No results are set for the ParseMock.ParseHeading")
		}
		return (*mm_results).m1, (*mm_results).m2
	}
	if mmParseHeading.funcParseHeading != nil {
		return mmParseHeading.funcParseHeading(fileCols, flgCols)
	}
	mmParseHeading.t.Fatalf("Unexpected call to ParseMock.ParseHeading. %v %v", fileCols, flgCols)
	return
}

// ParseHeadingAfterCounter returns a count of finished ParseMock.ParseHeading invocations
func (mmParseHeading *ParseMock) ParseHeadingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseHeading.afterParseHeadingCounter)
}

// ParseHeadingBeforeCounter returns a count of ParseMock.ParseHeading invocations
func (mmParseHeading *ParseMock) ParseHeadingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmParseHeading.beforeParseHeadingCounter)
}

// Calls returns a list of arguments used in each call to ParseMock.ParseHeading.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmParseHeading *mParseMockParseHeading) Calls() []*ParseMockParseHeadingParams {
	mmParseHeading.mutex.RLock()

	argCopy := make([]*ParseMockParseHeadingParams, len(mmParseHeading.callArgs))
	copy(argCopy, mmParseHeading.callArgs)

	mmParseHeading.mutex.RUnlock()

	return argCopy
}

// MinimockParseHeadingDone returns true if the count of the ParseHeading invocations corresponds
// the number of defined expectations
func (m *ParseMock) MinimockParseHeadingDone() bool {
	for _, e := range m.ParseHeadingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseHeadingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseHeadingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseHeading != nil && mm_atomic.LoadUint64(&m.afterParseHeadingCounter) < 1 {
		return false
	}
	return true
}

// MinimockParseHeadingInspect logs each unmet expectation
func (m *ParseMock) MinimockParseHeadingInspect() {
	for _, e := range m.ParseHeadingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParseMock.ParseHeading with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ParseHeadingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterParseHeadingCounter) < 1 {
		if m.ParseHeadingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParseMock.ParseHeading")
		} else {
			m.t.Errorf("Expected call to ParseMock.ParseHeading with params: %#v", *m.ParseHeadingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcParseHeading != nil && mm_atomic.LoadUint64(&m.afterParseHeadingCounter) < 1 {
		m.t.Error("Expected call to ParseMock.ParseHeading")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ParseMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockParseConditionInspect()

		m.MinimockParseHeadingInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ParseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ParseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockParseConditionDone() &&
		m.MinimockParseHeadingDone()
}
